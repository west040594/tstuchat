{"version":3,"sources":["webpack://StompJs/webpack/universalModuleDefinition","webpack://StompJs/webpack/bootstrap","webpack://StompJs/./src/versions.ts","webpack://StompJs/./src/frame.ts","webpack://StompJs/./src/compatibility/compat-client.ts","webpack://StompJs/./src/parser.ts","webpack://StompJs/./src/byte.ts","webpack://StompJs/./src/client.ts","webpack://StompJs/./src/compatibility/stomp.ts","webpack://StompJs/./src/compatibility/heartbeat-info.ts","webpack://StompJs/./src/transaction.ts","webpack://StompJs/./src/stomp-subscription.ts","webpack://StompJs/./src/stomp-headers.ts","webpack://StompJs/./src/stomp-config.ts","webpack://StompJs/./src/message.ts","webpack://StompJs/./src/stomp-handler.ts","webpack://StompJs/./src/index.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Versions","versions","this","supportedVersions","join","protocolVersions","map","x","replace","V1_0","V1_1","V1_2","default","byte_1","Frame","params","command","headers","body","binaryBody","escapeHeaderValues","skipContentLengthHeader","assign","_binaryBody","isBinaryBody","_body","TextDecoder","decode","TextEncoder","encode","fromRawFrame","rawFrame","trim","str","_i","_a","reverse","length","header","indexOf","hdrValueUnEscape","toString","serializeCmdAndHeaders","serialize","cmdAndHeaders","toUnit8Array","buffer","BYTE","NULL","lines","keys","name_1","push","hdrValueEscape","isBodyEmpty","bodyLength","LF","sizeOfUTF8","uint8CmdAndHeaders","nullTerminator","Uint8Array","uint8Frame","set","marshall","client_1","heartbeat_info_1","CompatClient","_super","webSocketFactory","_this","maxWebSocketFrameSize","_heartbeatInfo","HeartbeatInfo","reconnect_delay","debug","message","arguments","console","log","apply","__extends","_parseConnect","closeEventCallback","connectCallback","errorCallback","args","Error","login","passcode","host","connect","out","connectHeaders","onConnect","onStompError","onWebSocketClose","activate","disconnect","disconnectCallback","onDisconnect","disconnectHeaders","deactivate","send","destination","publish","reconnectDelay","_webSocket","connectedVersion","onUnhandledMessage","onUnhandledReceipt","heartbeatIncoming","incoming","heartbeatOutgoing","outgoing","Client","Parser","onFrame","onIncomingPing","_encoder","_decoder","_token","_initState","parseChunk","segment","chunk","ArrayBuffer","byte","_onByte","_collectFrame","_collectCommand","_reinjectByte","_results","_consumeTokenAsUTF8","_collectHeaders","_consumeByte","_collectHeaderKey","_setupCollectBody","_headerKey","_collectHeaderValue","undefined","contentLengthHeader","filter","_bodyBytesRemaining","parseInt","_collectBodyFixedSize","_collectBodyNullTerminated","_retrievedBody","_consumeTokenAsRaw","rawResult","stomp_handler_1","versions_1","conf","stompVersions","_active","noOp","beforeConnect","onUnhandledFrame","_disconnectHeaders","configure","_stompHandler","connected","_connect","_createWebSocket","StompHandler","frame","_disposeStompHandler","evt","_schedule_reconnect","start","webSocket","WebSocket","brokerURL","binaryType","_reconnector","setTimeout","clearTimeout","forceDisconnect","readyState","CONNECTING","OPEN","close","dispose","watchForReceipt","receiptId","callback","subscribe","unsubscribe","id","begin","transactionId","commit","abort","ack","messageId","subscriptionId","nack","compat_client_1","Stomp","client","url","protocols","WebSocketClass","over","ws","wsFn","Transaction","StompSubscription","StompHeaders","StompConfig","Message","frame_1","parser_1","_client","config","_serverFrameHandlers","CONNECTED","server","_connected","_connectedVersion","version","_escapeHeaderValues","_setupHeartbeat","MESSAGE","subscription","onReceive","_subscriptions","RECEIPT","_receiptWatchers","ERROR","_counter","_partialData","_lastServerActivityTS","Date","now","parser","onmessage","data","onclose","closeEvent","_cleanUp","onopen","_transmit","split","v","serverOutgoing","serverIncoming","ttl","Math","max","_pinger","setInterval","ttl_1","_ponger","delta","receipt","error","clearInterval","hdrs","txId","transaction","__export"],"mappings":"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","file":"stomp.umd.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"StompJs\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"StompJs\"] = factory();\n\telse\n\t\troot[\"StompJs\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 15);\n","/**\n * Supported STOMP versions\n *\n * Part of `@stomp/stompjs`.\n */\nexport class Versions {\n  /**\n   * Indicates protocol version 1.0\n   */\n  public static V1_0 = '1.0';\n  /**\n   * Indicates protocol version 1.1\n   */\n  public static V1_1 = '1.1';\n  /**\n   * Indicates protocol version 1.2\n   */\n  public static V1_2 = '1.2';\n\n  /**\n   * @internal\n   */\n  public static default = new Versions([Versions.V1_0, Versions.V1_1, Versions.V1_2]);\n\n  /**\n   * Takes an array of string of versions, typical elements '1.0', '1.1', or '1.2'\n   *\n   * You will an instance if this class if you want to override supported versions to be declared during\n   * STOMP handshake.\n   */\n  constructor(public versions: string[]) {\n  }\n\n  /**\n   * Used as part of CONNECT STOMP Frame\n   */\n  public supportedVersions() {\n    return this.versions.join(',');\n  }\n\n  /**\n   * Used while creating a WebSocket\n   */\n  public protocolVersions() {\n    return this.versions.map((x) => `v${x.replace('.', '')}.stomp`);\n  }\n}\n","import {BYTE} from './byte';\nimport {StompHeaders} from './stomp-headers';\nimport {IRawFrameType} from './types';\n\n/**\n * Frame class represents a STOMP frame. Many of the callbacks pass the Frame received from\n * the STOMP broker. For advanced usage you might need to access [headers]{@link Frame#headers}.\n *\n * Part of `@stomp/stompjs`.\n *\n * {@link Message} is an extended Frame.\n */\nexport class Frame {\n  /**\n   * STOMP Command\n   */\n  public command: string;\n\n  /**\n   * Headers, key value pairs.\n   */\n  public headers: StompHeaders;\n\n  /**\n   * Is this frame binary (based on whether body/binaryBody was passed when creating this frame).\n   */\n  public isBinaryBody: boolean;\n\n  /**\n   * body of the frame\n   */\n  get body(): string {\n    if (!this._body && this.isBinaryBody) {\n      this._body = new TextDecoder().decode(this._binaryBody);\n    }\n    return this._body;\n  }\n  private _body: string;\n\n  /**\n   * body as Uint8Array\n   */\n  get binaryBody(): Uint8Array {\n    if (!this._binaryBody && !this.isBinaryBody) {\n      this._binaryBody = new TextEncoder().encode(this._body);\n    }\n    return this._binaryBody;\n  }\n  private _binaryBody: Uint8Array;\n\n  private escapeHeaderValues: boolean;\n  private skipContentLengthHeader: boolean;\n\n  /**\n   * Frame constructor. `command`, `headers` and `body` are available as properties.\n   *\n   * @internal\n   */\n  constructor(params: {\n    command: string, headers?: StompHeaders, body?: string, binaryBody?: Uint8Array,\n    escapeHeaderValues?: boolean, skipContentLengthHeader?: boolean\n  }) {\n    const {command, headers, body, binaryBody, escapeHeaderValues, skipContentLengthHeader} = params;\n    this.command = command;\n    this.headers = (Object as any).assign({}, headers || {});\n\n    if (binaryBody) {\n      this._binaryBody = binaryBody;\n      this.isBinaryBody = true;\n    } else {\n      this._body = body || '';\n      this.isBinaryBody = false;\n    }\n    this.escapeHeaderValues = escapeHeaderValues || false;\n    this.skipContentLengthHeader = skipContentLengthHeader || false;\n  }\n\n  /**\n   * deserialize a STOMP Frame from raw data.\n   *\n   * @internal\n   */\n  public static fromRawFrame(rawFrame: IRawFrameType, escapeHeaderValues: boolean): Frame {\n    const headers: StompHeaders = {};\n    const trim = (str: string): string => str.replace(/^\\s+|\\s+$/g, '');\n\n    // In case of repeated headers, as per standards, first value need to be used\n    for (const header of rawFrame.headers.reverse()) {\n      const idx = header.indexOf(':');\n\n      const key = trim(header[0]);\n      let value = trim(header[1]);\n\n      if (escapeHeaderValues && (rawFrame.command !== 'CONNECT') && (rawFrame.command !== 'CONNECTED')) {\n        value = Frame.hdrValueUnEscape(value);\n      }\n\n      headers[key] = value;\n    }\n\n    return new Frame({\n      command: rawFrame.command,\n      headers,\n      binaryBody: rawFrame.binaryBody,\n      escapeHeaderValues\n    });\n  }\n\n  /**\n   * @internal\n   */\n  public toString(): string {\n    return this.serializeCmdAndHeaders();\n  }\n\n  /**\n   * serialize this Frame in a format suitable to be passed to WebSocket.\n   * If the body is string the output will be string.\n   * If the body is binary (i.e. of type Unit8Array) it will be serialized to ArrayBuffer.\n   *\n   * @internal\n   */\n  public serialize(): string|ArrayBuffer {\n    const cmdAndHeaders = this.serializeCmdAndHeaders();\n\n    if (this.isBinaryBody) {\n      return Frame.toUnit8Array(cmdAndHeaders, this._binaryBody).buffer;\n    } else {\n      return cmdAndHeaders + this._body + BYTE.NULL;\n    }\n  }\n\n  private serializeCmdAndHeaders(): string {\n    const lines = [this.command];\n    if (this.skipContentLengthHeader) {\n      delete this.headers['content-length'];\n    }\n\n    for (const name of Object.keys(this.headers || {})) {\n      const value = this.headers[name];\n      if (this.escapeHeaderValues && (this.command !== 'CONNECT') && (this.command !== 'CONNECTED')) {\n        lines.push(`${name}:${Frame.hdrValueEscape(`${value}`)}`);\n      } else {\n        lines.push(`${name}:${value}`);\n      }\n    }\n    if (this.isBinaryBody || (!this.isBodyEmpty() && !this.skipContentLengthHeader)) {\n      lines.push(`content-length:${this.bodyLength()}`);\n    }\n    return lines.join(BYTE.LF) + BYTE.LF + BYTE.LF;\n  }\n\n  private isBodyEmpty(): boolean {\n    return this.bodyLength() === 0;\n  }\n\n  private bodyLength(): number {\n    const binaryBody = this.binaryBody;\n    return binaryBody ? binaryBody.length : 0;\n  }\n\n  /**\n   * Compute the size of a UTF-8 string by counting its number of bytes\n   * (and not the number of characters composing the string)\n   */\n  private static sizeOfUTF8(s: string): number {\n    return s ? new TextEncoder().encode(s).length : 0;\n  }\n\n  private static toUnit8Array(cmdAndHeaders: string, binaryBody: Uint8Array): Uint8Array {\n    const uint8CmdAndHeaders = new TextEncoder().encode(cmdAndHeaders);\n    const nullTerminator = new Uint8Array([0]);\n    const uint8Frame = new Uint8Array(uint8CmdAndHeaders.length + binaryBody.length + nullTerminator.length);\n\n    uint8Frame.set(uint8CmdAndHeaders);\n    uint8Frame.set(binaryBody, uint8CmdAndHeaders.length);\n    uint8Frame.set(nullTerminator, uint8CmdAndHeaders.length + binaryBody.length);\n\n    return uint8Frame;\n  }\n  /**\n   * Serialize a STOMP frame as per STOMP standards, suitable to be sent to the STOMP broker.\n   *\n   * @internal\n   */\n  public static marshall(params: {\n    command: string, headers?: StompHeaders, body?: string, binaryBody?: Uint8Array,\n    escapeHeaderValues?: boolean, skipContentLengthHeader?: boolean\n  }) {\n    const frame = new Frame(params);\n    return frame.serialize();\n  }\n\n  /**\n   *  Escape header values\n   */\n  private static hdrValueEscape(str: string): string {\n    return str.replace(/\\\\/g, '\\\\\\\\').replace(/\\r/g, '\\\\r').replace(/\\n/g, '\\\\n').replace(/:/g, '\\\\c');\n  }\n\n  /**\n   * UnEscape header values\n   */\n  private static hdrValueUnEscape(str: string): string {\n    return str.replace(/\\\\r/g, '\\r').replace(/\\\\n/g, '\\n').replace(/\\\\c/g, ':').replace(/\\\\\\\\/g, '\\\\');\n  }\n}\n","import {Client} from '../client';\nimport {StompHeaders} from '../stomp-headers';\nimport {frameCallbackType, messageCallbackType} from '../types';\nimport {HeartbeatInfo} from './heartbeat-info';\n\n/**\n * Available for backward compatibility, please shift to using {@link Client}.\n *\n * **Deprecated**\n *\n * Part of `@stomp/stompjs`.\n *\n * To upgrade, please follow the [Upgrade Guide](../additional-documentation/upgrading.html)\n */\nexport class CompatClient extends Client {\n\n  /**\n   * It is no op now. No longer needed. Large packets work out of the box.\n   */\n  public maxWebSocketFrameSize: number = 16 * 1024;\n\n  /**\n   * Available for backward compatibility, please shift to using {@link Client}\n   * and [Client#webSocketFactory]{@link Client#webSocketFactory}.\n   *\n   * **Deprecated**\n   *\n   * @internal\n   */\n  constructor(webSocketFactory: () => any) {\n    super();\n    this.reconnect_delay = 0;\n    this.webSocketFactory = webSocketFactory;\n    // Default from previous version\n    this.debug = (...message: any[]) => {\n      console.log(...message);\n    };\n  }\n\n  private _parseConnect(...args: any[]): any {\n    let closeEventCallback;\n    let connectCallback;\n    let errorCallback;\n    let headers: StompHeaders = {};\n    if (args.length < 2) {\n      throw new Error(('Connect requires at least 2 arguments'));\n    }\n    if (typeof(args[1]) === 'function') {\n      [headers, connectCallback, errorCallback, closeEventCallback] = args;\n    } else {\n      switch (args.length) {\n        case 6:\n          [headers.login, headers.passcode, connectCallback, errorCallback, closeEventCallback, headers.host] = args;\n          break;\n        default:\n          [headers.login, headers.passcode, connectCallback, errorCallback, closeEventCallback] = args;\n      }\n    }\n\n    return [headers, connectCallback, errorCallback, closeEventCallback];\n  }\n\n  /**\n   * Available for backward compatibility, please shift to using [Client#activate]{@link Client#activate}.\n   *\n   * **Deprecated**\n   *\n   * The `connect` method accepts different number of arguments and types. See the Overloads list. Use the\n   * version with headers to pass your broker specific options.\n   *\n   * overloads:\n   * - connect(headers, connectCallback)\n   * - connect(headers, connectCallback, errorCallback)\n   * - connect(login, passcode, connectCallback)\n   * - connect(login, passcode, connectCallback, errorCallback)\n   * - connect(login, passcode, connectCallback, errorCallback, closeEventCallback)\n   * - connect(login, passcode, connectCallback, errorCallback, closeEventCallback, host)\n   *\n   * params:\n   * - headers, see [Client#connectHeaders]{@link Client#connectHeaders}\n   * - connectCallback, see [Client#onConnect]{@link Client#onConnect}\n   * - errorCallback, see [Client#onStompError]{@link Client#onStompError}\n   * - closeEventCallback, see [Client#onWebSocketClose]{@link Client#onWebSocketClose}\n   * - login [String], see [Client#connectHeaders](../classes/Client.html#connectHeaders)\n   * - passcode [String], [Client#connectHeaders](../classes/Client.html#connectHeaders)\n   * - host [String], see [Client#connectHeaders](../classes/Client.html#connectHeaders)\n   *\n   * To upgrade, please follow the [Upgrade Guide](../additional-documentation/upgrading.html)\n   */\n  public connect(...args: any[]): void {\n    const out = this._parseConnect(...args);\n\n    if (out[0]) { this.connectHeaders = out[0]; }\n    if (out[1]) { this.onConnect = out[1]; }\n    if (out[2]) { this.onStompError = out[2]; }\n    if (out[3]) { this.onWebSocketClose = out[3]; }\n\n    super.activate();\n  }\n\n  /**\n   * Available for backward compatibility, please shift to using [Client#deactivate]{@link Client#deactivate}.\n   *\n   * **Deprecated**\n   *\n   * See:\n   * [Client#onDisconnect]{@link Client#onDisconnect}, and\n   * [Client#disconnectHeaders]{@link Client#disconnectHeaders}\n   *\n   * To upgrade, please follow the [Upgrade Guide](../additional-documentation/upgrading.html)\n   */\n  public disconnect(disconnectCallback?: any, headers: StompHeaders = {}): void {\n    if (disconnectCallback) {\n      this.onDisconnect = disconnectCallback;\n    }\n    this.disconnectHeaders = headers;\n\n    super.deactivate();\n  }\n\n  /**\n   * Available for backward compatibility, use [Client#publish]{@link Client#publish}.\n   *\n   * Send a message to a named destination. Refer to your STOMP broker documentation for types\n   * and naming of destinations. The headers will, typically, be available to the subscriber.\n   * However, there may be special purpose headers corresponding to your STOMP broker.\n   *\n   *  **Deprecated**, use [Client#publish]{@link Client#publish}\n   *\n   * Note: Body must be String. You will need to covert the payload to string in case it is not string (e.g. JSON)\n   *\n   * ```javascript\n   *        client.send(\"/queue/test\", {priority: 9}, \"Hello, STOMP\");\n   *\n   *        // If you want to send a message with a body, you must also pass the headers argument.\n   *        client.send(\"/queue/test\", {}, \"Hello, STOMP\");\n   * ```\n   *\n   * To upgrade, please follow the [Upgrade Guide](../additional-documentation/upgrading.html)\n   */\n  public send(destination: string, headers: {[key: string]: any} = {}, body: string = ''): void {\n    headers = (Object as any).assign({}, headers);\n\n    const skipContentLengthHeader = (headers['content-length'] === false);\n    if (skipContentLengthHeader) {\n      delete headers['content-length'];\n    }\n    this.publish({\n      destination,\n      headers: headers as StompHeaders,\n      body,\n      skipContentLengthHeader\n    });\n  }\n\n  /**\n   * Available for backward compatibility, renamed to [Client#reconnectDelay]{@link Client#reconnectDelay}.\n   *\n   * **Deprecated**\n   */\n  set reconnect_delay(value: number) {\n    this.reconnectDelay = value;\n  }\n\n  /**\n   * Available for backward compatibility, renamed to [Client#webSocket]{@link Client#webSocket}.\n   *\n   * **Deprecated**\n   */\n  get ws(): any {\n    return this._webSocket;\n  }\n\n  /**\n   * Available for backward compatibility, renamed to [Client#connectedVersion]{@link Client#connectedVersion}.\n   *\n   * **Deprecated**\n   */\n  get version() {\n    return this.connectedVersion;\n  }\n\n  /**\n   * Available for backward compatibility, renamed to [Client#onUnhandledMessage]{@link Client#onUnhandledMessage}.\n   *\n   * **Deprecated**\n   */\n  get onreceive(): messageCallbackType {\n    return this.onUnhandledMessage;\n  }\n\n  /**\n   * Available for backward compatibility, renamed to [Client#onUnhandledMessage]{@link Client#onUnhandledMessage}.\n   *\n   * **Deprecated**\n   */\n  set onreceive(value: messageCallbackType) {\n    this.onUnhandledMessage = value;\n  }\n\n  /**\n   * Available for backward compatibility, renamed to [Client#onUnhandledReceipt]{@link Client#onUnhandledReceipt}.\n   * Prefer using [Client#watchForReceipt]{@link Client#watchForReceipt}.\n   *\n   * **Deprecated**\n   */\n  get onreceipt(): frameCallbackType {\n    return this.onUnhandledReceipt;\n  }\n\n  /**\n   * Available for backward compatibility, renamed to [Client#onUnhandledReceipt]{@link Client#onUnhandledReceipt}.\n   *\n   * **Deprecated**\n   */\n  set onreceipt(value: frameCallbackType) {\n    this.onUnhandledReceipt = value;\n  }\n\n  private _heartbeatInfo: HeartbeatInfo = new HeartbeatInfo(this);\n\n  /**\n   * Available for backward compatibility, renamed to [Client#heartbeatIncoming]{@link Client#heartbeatIncoming}\n   * [Client#heartbeatOutgoing]{@link Client#heartbeatOutgoing}.\n   *\n   * **Deprecated**\n   */\n  get heartbeat() {\n    return this._heartbeatInfo;\n  }\n\n  /**\n   * Available for backward compatibility, renamed to [Client#heartbeatIncoming]{@link Client#heartbeatIncoming}\n   * [Client#heartbeatOutgoing]{@link Client#heartbeatOutgoing}.\n   *\n   * **Deprecated**\n   */\n  set heartbeat(value: {incoming: number, outgoing: number}) {\n    this.heartbeatIncoming = value.incoming;\n    this.heartbeatOutgoing = value.outgoing;\n  }\n}\n","import {IRawFrameType} from './types';\n\n/**\n * @internal\n */\nconst NULL = 0;\n/**\n * @internal\n */\nconst LF = 10;\n/**\n * @internal\n */\nconst CR = 13;\n/**\n * @internal\n */\nconst COLON = 58;\n\n/**\n * This is an evented, rec descent parser.\n * A stream of Octets can be passed and whenever it recognizes\n * a complete Frame or an incoming ping it will invoke the registered callbacks.\n *\n * All incoming Octets are fed into _onByte function.\n * Depending on current state the _onByte function keeps changing.\n * Depending on the state it keeps accumulating into _token and _results.\n * State is indicated by current value of _onByte, all states are named as _collect.\n *\n * STOMP standards https://stomp.github.io/stomp-specification-1.2.html\n * imply that all lengths are considered in bytes (instead of string lengths).\n * So, before actual parsing, if the incoming data is String it is converted to Octets.\n * This allows faithful implementation of the protocol and allows NULL Octets to be present in the body.\n *\n * There is no peek function on the incoming data.\n * When a state change occurs based on an Octet without consuming the Octet,\n * the Octet, after state change, is fed again (_reinjectByte).\n * This became possible as the state change can be determined by inspecting just one Octet.\n *\n * There are two modes to collect the body, if content-length header is there then it by counting Octets\n * otherwise it is determined by NULL terminator.\n *\n * Following the standards, the command and headers are converted to Strings\n * and the body is returned as Octets.\n * Headers are returned as an array and not as Hash - to allow multiple occurrence of an header.\n *\n * This parser does not use Regular Expressions as that can only operate on Strings.\n *\n * It handles if multiple STOMP frames are given as one chunk, a frame is split into multiple chunks, or\n * any combination there of. The parser remembers its state (any partial frame) and continues when a new chunk\n * is pushed.\n *\n * Typically the higher level function will convert headers to Hash, handle unescaping of header values\n * (which is protocol version specific), and convert body to text.\n *\n * Check the parser.spec.js to understand cases that this parser is supposed to handle.\n *\n * Part of `@stomp/stompjs`.\n *\n * @internal\n */\nexport class Parser {\n  private readonly _encoder = new TextEncoder();\n  private readonly _decoder = new TextDecoder();\n\n  private _results: IRawFrameType;\n\n  private _token: number[] = [];\n  private _headerKey: string;\n  private _bodyBytesRemaining: number;\n\n  private _onByte: (byte: number) => void;\n\n  public constructor(public onFrame: (rawFrame: IRawFrameType) => void, public onIncomingPing: () => void) {\n    this._initState();\n  }\n\n  public parseChunk(segment: string|ArrayBuffer) {\n    let chunk: Uint8Array;\n\n    if ((segment instanceof ArrayBuffer)) {\n      chunk = new Uint8Array(segment);\n    } else {\n      chunk = this._encoder.encode(segment);\n    }\n\n    // tslint:disable-next-line:prefer-for-of\n    for (let i = 0; i < chunk.length; i++) {\n      const byte = chunk[i];\n      this._onByte(byte);\n    }\n  }\n\n  // The following implements a simple Rec Descent Parser.\n  // The grammar is simple and just one byte tells what should be the next state\n\n  private _collectFrame(byte: number): void {\n    if (byte === NULL) { // Ignore\n      return;\n    }\n    if (byte === CR) { // Ignore CR\n      return;\n    }\n    if (byte === LF) { // Incoming Ping\n      this.onIncomingPing();\n      return;\n    }\n\n    this._onByte = this._collectCommand;\n    this._reinjectByte(byte);\n  }\n\n  private _collectCommand(byte: number): void {\n    if (byte === CR) { // Ignore CR\n      return;\n    }\n    if (byte === LF) {\n      this._results.command = this._consumeTokenAsUTF8();\n      this._onByte = this._collectHeaders;\n      return;\n    }\n\n    this._consumeByte(byte);\n  }\n\n  private _collectHeaders(byte: number): void {\n    if (byte === CR) { // Ignore CR\n      return;\n    }\n    if (byte === LF) {\n      this._setupCollectBody();\n      return;\n    }\n    this._onByte = this._collectHeaderKey;\n    this._reinjectByte(byte);\n  }\n\n  private _reinjectByte(byte: number) {\n    this._onByte(byte);\n  }\n\n  private _collectHeaderKey(byte: number): void {\n    if (byte === COLON) {\n      this._headerKey = this._consumeTokenAsUTF8();\n      this._onByte = this._collectHeaderValue;\n      return;\n    }\n    this._consumeByte(byte);\n  }\n\n  private _collectHeaderValue(byte: number): void {\n    if (byte === CR) { // Ignore CR\n      return;\n    }\n    if (byte === LF) {\n      this._results.headers.push([this._headerKey, this._consumeTokenAsUTF8()]);\n      this._headerKey = undefined;\n      this._onByte = this._collectHeaders;\n      return;\n    }\n    this._consumeByte(byte);\n  }\n\n  private _setupCollectBody() {\n    const contentLengthHeader = this._results.headers.filter((header: [string, string]) => {\n      return header[0] === 'content-length';\n    })[0];\n\n    if (contentLengthHeader) {\n      this._bodyBytesRemaining = parseInt(contentLengthHeader[1], 10);\n      this._onByte = this._collectBodyFixedSize;\n    } else {\n      this._onByte = this._collectBodyNullTerminated;\n    }\n  }\n\n  private _collectBodyNullTerminated(byte: number): void {\n    if (byte === NULL) {\n      this._retrievedBody();\n      return;\n    }\n    this._consumeByte(byte);\n  }\n\n  private _collectBodyFixedSize(byte: number): void {\n    // It is post decrement, so that we discard the trailing NULL octet\n    if (this._bodyBytesRemaining-- === 0) {\n      this._retrievedBody();\n      return;\n    }\n    this._consumeByte(byte);\n  }\n\n  private _retrievedBody() {\n    this._results.binaryBody = this._consumeTokenAsRaw();\n\n    this.onFrame(this._results);\n\n    this._initState();\n  }\n\n  // Rec Descent Parser helpers\n\n  private _consumeByte(byte: number) {\n    this._token.push(byte);\n  }\n\n  private _consumeTokenAsUTF8() {\n    return this._decoder.decode(this._consumeTokenAsRaw());\n  }\n\n  private _consumeTokenAsRaw() {\n    const rawResult = new Uint8Array(this._token);\n    this._token = [];\n    return rawResult;\n  }\n\n  private _initState() {\n    this._results = {\n      command: undefined,\n      headers: [],\n      binaryBody: undefined\n    };\n\n    this._token = [];\n    this._headerKey = undefined;\n\n    this._onByte = this._collectFrame;\n  }\n\n}\n","/**\n * Some byte values, used as per STOMP specifications.\n *\n * Part of `@stomp/stompjs`.\n *\n * @internal\n */\nexport const BYTE = {\n  // LINEFEED byte (octet 10)\n  LF: '\\x0A',\n  // NULL byte (octet 0)\n  NULL: '\\x00'\n};\n","import {StompConfig} from './stomp-config';\nimport {StompHandler} from './stomp-handler';\nimport {StompHeaders} from './stomp-headers';\nimport {StompSubscription} from './stomp-subscription';\nimport {Transaction} from './transaction';\nimport {\n  closeEventCallbackType,\n  debugFnType,\n  frameCallbackType,\n  IPublishParams,\n  messageCallbackType\n} from './types';\nimport {Versions} from './versions';\n\n/**\n * STOMP Client Class.\n *\n * Part of `@stomp/stompjs`.\n */\nexport class Client {\n  /**\n   * The URL for the STOMP broker to connect to.\n   * Typically like `\"ws://broker.329broker.com:15674/ws\"` or `\"wss://broker.329broker.com:15674/ws\"`.\n   *\n   * Only one of this or [Client#webSocketFactory]{@link Client#webSocketFactory} need to be set.\n   * If both are set, [Client#webSocketFactory]{@link Client#webSocketFactory} will be used.\n   */\n  public brokerURL: string;\n\n  /**\n   * STOMP versions to attempt during STOMP handshake. By default versions `1.0`, `1.1`, and `1.2` are attempted.\n   *\n   * Example:\n   * ```javascript\n   *        // Try only versions 1.0 and 1.1\n   *        client.stompVersions = new Versions(['1.0', '1.1'])\n   * ```\n   */\n  public stompVersions = Versions.default;\n\n  /**\n   * This function should return a WebSocket or a similar (e.g. SockJS) object.\n   * If your STOMP Broker supports WebSockets, prefer setting [Client#brokerURL]{@link Client#brokerURL}.\n   *\n   * If both this and [Client#brokerURL]{@link Client#brokerURL} are set, this will be used.\n   *\n   * Example:\n   * ```javascript\n   *        // use a WebSocket\n   *        client.webSocketFactory= function () {\n   *          return new WebSocket(\"wss://broker.329broker.com:15674/ws\");\n   *        };\n   *\n   *        // Typical usage with SockJS\n   *        client.webSocketFactory= function () {\n   *          return new SockJS(\"http://broker.329broker.com/stomp\");\n   *        };\n   * ```\n   */\n  public webSocketFactory: () => WebSocket;\n\n  /**\n   *  automatically reconnect with delay in milliseconds, set to 0 to disable.\n   */\n  public reconnectDelay: number = 5000;\n\n  /**\n   * Incoming heartbeat interval in milliseconds. Set to 0 to disable.\n   */\n  public heartbeatIncoming: number = 10000;\n\n  /**\n   * Outgoing heartbeat interval in milliseconds. Set to 0 to disable.\n   */\n  public heartbeatOutgoing: number = 10000;\n\n  /**\n   * Underlying WebSocket instance, READONLY.\n   */\n  get webSocket(): WebSocket {\n    return this._webSocket;\n  }\n  /**\n   * Underlying WebSocket instance\n   * @internal\n   */\n  protected _webSocket: WebSocket;\n\n  /**\n   * Connection headers, important keys - `login`, `passcode`, `host`.\n   * Though STOMP 1.2 standard marks these keys to be present, check your broker documentation for\n   * details specific to your broker.\n   */\n  public connectHeaders: StompHeaders;\n\n  /**\n   * Disconnection headers.\n   */\n  get disconnectHeaders(): StompHeaders {\n    return this._disconnectHeaders;\n  }\n\n  set disconnectHeaders(value: StompHeaders) {\n    this._disconnectHeaders = value;\n    if (this._stompHandler) {\n      this._stompHandler.disconnectHeaders = this._disconnectHeaders;\n    }\n  }\n  private _disconnectHeaders: StompHeaders;\n\n  /**\n   * This function will be called for any unhandled messages.\n   * It is useful for receiving messages sent to RabbitMQ temporary queues.\n   *\n   * It can also get invoked with stray messages while the server is processing\n   * a request to [Client#unsubscribe]{@link Client#unsubscribe}\n   * from an endpoint.\n   *\n   * The actual {@link Message} will be passed as parameter to the callback.\n   */\n  public onUnhandledMessage: messageCallbackType;\n\n  /**\n   * STOMP brokers can be requested to notify when an operation is actually completed.\n   * Prefer using [Client#watchForReceipt]{@link Client#watchForReceipt}. See\n   * [Client#watchForReceipt]{@link Client#watchForReceipt} for examples.\n   *\n   * The actual {@link Frame} will be passed as parameter to the callback.\n   */\n  public onUnhandledReceipt: frameCallbackType;\n\n  /**\n   * Will be invoked if {@link Frame} of unknown type is received from the STOMP broker.\n   *\n   * The actual {@link Frame} will be passed as parameter to the callback.\n   */\n  public onUnhandledFrame: frameCallbackType;\n\n  /**\n   * `true` if there is a active connection with STOMP Broker\n   */\n  get connected(): boolean {\n    return (!!this._stompHandler) && this._stompHandler.connected;\n  }\n\n  /**\n   * Callback, invoked on before a connection connection to the STOMP broker.\n   *\n   * You can change options on the client, which will impact the immediate connect.\n   * It is valid to call [Client#decativate]{@link Client#deactivate} in this callback.\n   */\n  public beforeConnect: () => void;\n\n  /**\n   * Callback, invoked on every successful connection to the STOMP broker.\n   *\n   * The actual {@link Frame} will be passed as parameter to the callback.\n   * Sometimes clients will like to use headers from this frame.\n   */\n  public onConnect: frameCallbackType;\n\n  /**\n   * Callback, invoked on every successful disconnection from the STOMP broker. It will not be invoked if\n   * the STOMP broker disconnected due to an error.\n   *\n   * The actual Receipt {@link Frame} acknowledging the DISCONNECT will be passed as parameter to the callback.\n   *\n   * The way STOMP protocol is designed, the connection may close/terminate without the client\n   * receiving the Receipt {@link Frame} acknowledging the DISCONNECT.\n   * You might find [Client#onWebSocketClose]{@link Client#onWebSocketClose} more appropriate to watch\n   * STOMP broker disconnects.\n   */\n  public onDisconnect: frameCallbackType;\n\n  /**\n   * Callback, invoked on an ERROR frame received from the STOMP Broker.\n   * A compliant STOMP Broker will close the connection after this type of frame.\n   * Please check broker specific documentation for exact behavior.\n   *\n   * The actual {@link Frame} will be passed as parameter to the callback.\n   */\n  public onStompError: frameCallbackType;\n\n  /**\n   * Callback, invoked when underlying WebSocket is closed.\n   *\n   * Actual [CloseEvent]{@link https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent}\n   * is passed as parameter to the callback.\n   */\n  public onWebSocketClose: closeEventCallbackType;\n\n  /**\n   * By default, debug messages are discarded. To log to `console` following can be used:\n   *\n   * ```javascript\n   *        client.debug = function(str) {\n   *          console.log(str);\n   *        };\n   * ```\n   *\n   * Currently this method does not support levels of log. Be aware that the output can be quite verbose\n   * and may contain sensitive information (like passwords, tokens etc.).\n   */\n  public debug: debugFnType;\n\n  /**\n   * version of STOMP protocol negotiated with the server, READONLY\n   */\n  get connectedVersion(): string {\n    return this._stompHandler ? this._stompHandler.connectedVersion : undefined;\n  }\n\n  private _stompHandler: StompHandler;\n\n  /**\n   * if the client is active (connected or going to reconnect)\n   */\n  get active(): boolean {\n    return this._active;\n  }\n  private _active: boolean = false;\n  private _reconnector: any;\n\n  /**\n   * Create an instance.\n   */\n  constructor(conf: StompConfig = {}) {\n    // Dummy callbacks\n    const noOp = () => {};\n    this.debug = noOp;\n    this.beforeConnect = noOp;\n    this.onConnect = noOp;\n    this.onDisconnect = noOp;\n    this.onUnhandledMessage = noOp;\n    this.onUnhandledReceipt = noOp;\n    this.onUnhandledFrame = noOp;\n    this.onStompError = noOp;\n    this.onWebSocketClose = noOp;\n\n    // These parameters would typically get proper values before connect is called\n    this.connectHeaders = {};\n    this._disconnectHeaders = {};\n\n    // Apply configuration\n    this.configure(conf);\n  }\n\n  /**\n   * Update configuration.\n   */\n  public configure(conf: StompConfig): void {\n    // bulk assign all properties to this\n    (Object as any).assign(this, conf);\n  }\n\n  /**\n   * Initiate the connection with the broker.\n   * If the connection breaks, as per [Client#reconnectDelay]{@link Client#reconnectDelay},\n   * it will keep trying to reconnect.\n   *\n   * Call [Client#deactivate]{@link Client#deactivate} to disconnect and stop reconnection attempts.\n   */\n  public activate(): void {\n    this._active = true;\n\n    this._connect();\n  }\n\n  private _connect(): void {\n    if (this.connected) {\n      this.debug('STOMP: already connected, nothing to do');\n      return;\n    }\n\n    this.beforeConnect();\n\n    if (!this._active) {\n      this.debug('Client has been marked inactive, will not attempt to connect');\n      return;\n    }\n\n    this.debug('Opening Web Socket...');\n\n    // Get the actual WebSocket (or a similar object)\n    this._webSocket = this._createWebSocket();\n\n    this._stompHandler = new StompHandler(this, this._webSocket, {\n      debug: this.debug,\n      stompVersions: this.stompVersions,\n      connectHeaders: this.connectHeaders,\n      disconnectHeaders: this._disconnectHeaders,\n      heartbeatIncoming: this.heartbeatIncoming,\n      heartbeatOutgoing: this.heartbeatOutgoing,\n      onConnect: (frame) => {\n        if (!this._active) {\n          this.debug('STOMP got connected while deactivate was issued, will disconnect now');\n          this._disposeStompHandler();\n          return;\n        }\n        this.onConnect(frame);\n      },\n      onDisconnect: (frame) => {\n        this.onDisconnect(frame);\n      },\n      onStompError: (frame) => {\n        this.onStompError(frame);\n      },\n      onWebSocketClose: (evt) => {\n        this.onWebSocketClose(evt);\n        // The callback is called before attempting to reconnect, this would allow the client\n        // to be `deactivated` in the callback.\n        if (this._active) {\n          this._schedule_reconnect();\n        }\n      },\n      onUnhandledMessage: (message) => {\n        this.onUnhandledMessage(message);\n      },\n      onUnhandledReceipt: (frame) => {\n        this.onUnhandledReceipt(frame);\n      },\n      onUnhandledFrame: (frame) => {\n        this.onUnhandledFrame(frame);\n      }\n    });\n\n    this._stompHandler.start();\n  }\n\n  private _createWebSocket() {\n    let webSocket: WebSocket;\n\n    if (this.webSocketFactory) {\n      webSocket = this.webSocketFactory();\n    } else {\n      webSocket = new WebSocket(this.brokerURL, this.stompVersions.protocolVersions());\n    }\n    webSocket.binaryType = 'arraybuffer';\n    return webSocket;\n  }\n\n  private _schedule_reconnect(): void {\n    if (this.reconnectDelay > 0) {\n      this.debug(`STOMP: scheduling reconnection in ${this.reconnectDelay}ms`);\n\n      this._reconnector = setTimeout(() => {\n        this._connect();\n      }, this.reconnectDelay);\n    }\n  }\n\n  /**\n   * Disconnect if connected and stop auto reconnect loop.\n   * Appropriate callbacks will be invoked if underlying STOMP connection was connected.\n   *\n   * To reactivate you can call [Client#activate]{@link Client#activate}.\n   */\n  public deactivate(): void {\n    // indicate that auto reconnect loop should terminate\n    this._active = false;\n\n    // Clear if a reconnection was scheduled\n    if (this._reconnector) {\n      clearTimeout(this._reconnector);\n    }\n    this._disposeStompHandler();\n  }\n\n  /**\n   * Force disconnect if there is an active connection by directly closing the underlying WebSocket.\n   * This is different than a normal disconnect where a DISCONNECT sequence is carried out with the broker.\n   * After forcing disconnect, automatic reconnect will be attempted.\n   * To stop further reconnects call [Client#deactivate]{@link Client#deactivate} as well.\n   */\n  public forceDisconnect() {\n    if (this._webSocket) {\n      if (this._webSocket.readyState === WebSocket.CONNECTING || this._webSocket.readyState === WebSocket.OPEN) {\n        this._webSocket.close();\n      }\n    }\n  }\n\n  private _disposeStompHandler() {\n    // Dispose STOMP Handler\n    if (this._stompHandler) {\n      this._stompHandler.dispose();\n      this._stompHandler = null;\n    }\n  }\n\n  /**\n   * Send a message to a named destination. Refer to your STOMP broker documentation for types\n   * and naming of destinations.\n   *\n   * STOMP protocol specifies and suggests some headers and also allows broker specific headers.\n   *\n   * `body` must be String.\n   * You will need to covert the payload to string in case it is not string (e.g. JSON).\n   *\n   * To send a binary message body use binaryBody parameter. It should be a\n   * [Uint8Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array).\n   * Sometimes brokers may not support binary frames out of the box.\n   * Please check your broker documentation.\n   *\n   * `content-length` header is automatically added to the STOMP Frame sent to the broker.\n   * Set `skipContentLengthHeader` to indicate that `content-length` header should not be added.\n   * For binary messages `content-length` header is always added.\n   *\n   * Caution: The broker will, most likely, report an error and disconnect if message body has NULL octet(s)\n   * and `content-length` header is missing.\n   *\n   * ```javascript\n   *        client.publish({destination: \"/queue/test\", headers: {priority: 9}, body: \"Hello, STOMP\"});\n   *\n   *        // Only destination is mandatory parameter\n   *        client.publish({destination: \"/queue/test\", body: \"Hello, STOMP\"});\n   *\n   *        // Skip content-length header in the frame to the broker\n   *        client.publish({\"/queue/test\", body: \"Hello, STOMP\", skipContentLengthHeader: true});\n   *\n   *        var binaryData = generateBinaryData(); // This need to be of type Uint8Array\n   *        // setting content-type header is not mandatory, however a good practice\n   *        client.publish({destination: '/topic/special', binaryBody: binaryData,\n   *                         headers: {'content-type': 'application/octet-stream'}});\n   * ```\n   */\n  public publish(params: IPublishParams) {\n    this._stompHandler.publish(params);\n  }\n\n  /**\n   * STOMP brokers may carry out operation asynchronously and allow requesting for acknowledgement.\n   * To request an acknowledgement, a `receipt` header needs to be sent with the actual request.\n   * The value (say receipt-id) for this header needs to be unique for each use. Typically a sequence, a UUID, a\n   * random number or a combination may be used.\n   *\n   * A complaint broker will send a RECEIPT frame when an operation has actually been completed.\n   * The operation needs to be matched based in the value of the receipt-id.\n   *\n   * This method allow watching for a receipt and invoke the callback\n   * when corresponding receipt has been received.\n   *\n   * The actual {@link Frame} will be passed as parameter to the callback.\n   *\n   * Example:\n   * ```javascript\n   *        // Subscribing with acknowledgement\n   *        let receiptId = randomText();\n   *\n   *        client.watchForReceipt(receiptId, function() {\n   *          // Will be called after server acknowledges\n   *        });\n   *\n   *        client.subscribe(TEST.destination, onMessage, {receipt: receiptId});\n   *\n   *\n   *        // Publishing with acknowledgement\n   *        receiptId = randomText();\n   *\n   *        client.watchForReceipt(receiptId, function() {\n   *          // Will be called after server acknowledges\n   *        });\n   *        client.publish({destination: TEST.destination, headers: {receipt: receiptId}, body: msg});\n   * ```\n   */\n  public watchForReceipt(receiptId: string, callback: frameCallbackType): void {\n    this._stompHandler.watchForReceipt(receiptId, callback);\n  }\n\n  /**\n   * Subscribe to a STOMP Broker location. The callback will be invoked for each received message with\n   * the {@link Message} as argument.\n   *\n   * Note: The library will generate an unique ID if there is none provided in the headers.\n   *       To use your own ID, pass it using the headers argument.\n   *\n   * ```javascript\n   *        callback = function(message) {\n   *        // called when the client receives a STOMP message from the server\n   *          if (message.body) {\n   *            alert(\"got message with body \" + message.body)\n   *          } else {\n   *            alert(\"got empty message\");\n   *          }\n   *        });\n   *\n   *        var subscription = client.subscribe(\"/queue/test\", callback);\n   *\n   *        // Explicit subscription id\n   *        var mySubId = 'my-subscription-id-001';\n   *        var subscription = client.subscribe(destination, callback, { id: mySubId });\n   * ```\n   */\n  public subscribe(destination: string, callback: messageCallbackType, headers: StompHeaders = {}): StompSubscription {\n    return this._stompHandler.subscribe(destination, callback, headers);\n  }\n\n  /**\n   * It is preferable to unsubscribe from a subscription by calling\n   * `unsubscribe()` directly on {@link StompSubscription} returned by `client.subscribe()`:\n   *\n   * ```javascript\n   *        var subscription = client.subscribe(destination, onmessage);\n   *        // ...\n   *        subscription.unsubscribe();\n   * ```\n   *\n   * See: http://stomp.github.com/stomp-specification-1.2.html#UNSUBSCRIBE UNSUBSCRIBE Frame\n   */\n  public unsubscribe(id: string, headers: StompHeaders = {}): void {\n    this._stompHandler.unsubscribe(id, headers);\n  }\n\n  /**\n   * Start a transaction, the returned {@link Transaction} has methods - [commit]{@link Transaction#commit}\n   * and [abort]{@link Transaction#abort}.\n   *\n   * `transactionId` is optional, if not passed the library will generate it internally.\n   */\n  public begin(transactionId?: string): Transaction {\n    return this._stompHandler.begin(transactionId);\n  }\n\n  /**\n   * Commit a transaction.\n   *\n   * It is preferable to commit a transaction by calling [commit]{@link Transaction#commit} directly on\n   * {@link Transaction} returned by [client.begin]{@link Client#begin}.\n   *\n   * ```javascript\n   *        var tx = client.begin(txId);\n   *        //...\n   *        tx.commit();\n   * ```\n   */\n  public commit(transactionId: string): void {\n    this._stompHandler.commit(transactionId);\n  }\n\n  /**\n   * Abort a transaction.\n   * It is preferable to abort a transaction by calling [abort]{@link Transaction#abort} directly on\n   * {@link Transaction} returned by [client.begin]{@link Client#begin}.\n   *\n   * ```javascript\n   *        var tx = client.begin(txId);\n   *        //...\n   *        tx.abort();\n   * ```\n   */\n  public abort(transactionId: string): void {\n    this._stompHandler.abort(transactionId);\n  }\n\n  /**\n   * ACK a message. It is preferable to acknowledge a message by calling [ack]{@link Message#ack} directly\n   * on the {@link Message} handled by a subscription callback:\n   *\n   * ```javascript\n   *        var callback = function (message) {\n   *          // process the message\n   *          // acknowledge it\n   *          message.ack();\n   *        };\n   *        client.subscribe(destination, callback, {'ack': 'client'});\n   * ```\n   */\n  public ack(messageId: string, subscriptionId: string, headers: StompHeaders = {}): void {\n    this._stompHandler.ack(messageId, subscriptionId, headers);\n  }\n\n  /**\n   * NACK a message. It is preferable to acknowledge a message by calling [nack]{@link Message#nack} directly\n   * on the {@link Message} handled by a subscription callback:\n   *\n   * ```javascript\n   *        var callback = function (message) {\n   *          // process the message\n   *          // an error occurs, nack it\n   *          message.nack();\n   *        };\n   *        client.subscribe(destination, callback, {'ack': 'client'});\n   * ```\n   */\n  public nack(messageId: string, subscriptionId: string, headers: StompHeaders = {}): void {\n    this._stompHandler.nack(messageId, subscriptionId, headers);\n  }\n}\n","import {Versions} from '../versions';\nimport {CompatClient} from './compat-client';\n\n/**\n * STOMP Class, acts like a factory to create {@link Client}.\n *\n * Part of `@stomp/stompjs`.\n *\n * **Deprecated**\n *\n * It will be removed in next major version. Please switch to {@link Client}.\n */\nexport class Stomp {\n  /**\n   * In case you need to use a non standard class for WebSocket.\n   *\n   * For example when using within NodeJS environment:\n   *\n   * ```javascript\n   *        StompJs = require('../../esm5/');\n   *        Stomp = StompJs.Stomp;\n   *        Stomp.WebSocketClass = require('websocket').w3cwebsocket;\n   * ```\n   *\n   * **Deprecated**\n   *\n   *\n   * It will be removed in next major version. Please switch to {@link Client}\n   * using [Client#webSocketFactory]{@link Client#webSocketFactory}.\n   */\n  // tslint:disable-next-line:variable-name\n  public static WebSocketClass: any = null;\n\n  /**\n   * This method creates a WebSocket client that is connected to\n   * the STOMP server located at the url.\n   *\n   * ```javascript\n   *        var url = \"ws://localhost:61614/stomp\";\n   *        var client = Stomp.client(url);\n   * ```\n   *\n   * **Deprecated**\n   *\n   * It will be removed in next major version. Please switch to {@link Client}\n   * using [Client#brokerURL]{@link Client#brokerURL}.\n   */\n  public static client(url: string, protocols?: string[]): CompatClient {\n    // This is a hack to allow another implementation than the standard\n    // HTML5 WebSocket class.\n    //\n    // It is possible to use another class by calling\n    //\n    //     Stomp.WebSocketClass = MozWebSocket\n    //\n    // *prior* to call `Stomp.client()`.\n    //\n    // This hack is deprecated and `Stomp.over()` method should be used\n    // instead.\n\n    // See remarks on the function Stomp.over\n    if (protocols == null) { protocols = Versions.default.protocolVersions(); }\n    const wsFn = () => {\n      const klass = Stomp.WebSocketClass || WebSocket;\n      return new klass(url, protocols);\n    };\n\n    return new CompatClient(wsFn);\n  }\n\n  /**\n   * This method is an alternative to [Stomp#client]{@link Stomp#client} to let the user\n   * specify the WebSocket to use (either a standard HTML5 WebSocket or\n   * a similar object).\n   *\n   * In order to support reconnection, the function Client._connect should be callable more than once.\n   * While reconnecting\n   * a new instance of underlying transport (TCP Socket, WebSocket or SockJS) will be needed. So, this function\n   * alternatively allows passing a function that should return a new instance of the underlying socket.\n   *\n   * ```javascript\n   *        var client = Stomp.over(function(){\n   *          return new WebSocket('ws://localhost:15674/ws')\n   *        });\n   * ```\n   *\n   * **Deprecated**\n   *\n   * It will be removed in next major version. Please switch to {@link Client}\n   * using [Client#webSocketFactory]{@link Client#webSocketFactory}.\n   */\n  public static over(ws: any): CompatClient {\n    const wsFn = typeof(ws) === 'function' ? ws : () => ws;\n\n    return new CompatClient(wsFn);\n  }\n}\n","import {CompatClient} from './compat-client';\n\n/**\n * Part of `@stomp/stompjs`.\n *\n * @internal\n */\nexport class HeartbeatInfo {\n  constructor(private client: CompatClient) {\n  }\n\n  get outgoing(): number {\n    return this.client.heartbeatOutgoing;\n  }\n\n  set outgoing(value: number) {\n    this.client.heartbeatOutgoing = value;\n  }\n\n  get incoming(): number {\n    return this.client.heartbeatIncoming;\n  }\n\n  set incoming(value: number) {\n    this.client.heartbeatIncoming = value;\n  }\n}\n","/**\n * A Transaction is created by calling [Client#begin]{@link Client#begin}\n *\n * Part of `@stomp/stompjs`.\n *\n * TODO: Example and caveat\n */\nexport class Transaction {\n  /**\n   * You will need to access this to send, ack, or nack within this transaction.\n   */\n  public id: string;\n\n  /**\n   * Commit this transaction. See [Client#commit]{@link Client#commit} for an example.\n   */\n  public commit: () => void;\n\n  /**\n   * Abort this transaction. See [Client#abort]{@link Client#abort} for an example.\n   */\n  public abort: () => void;\n}\n","import {StompHeaders} from './stomp-headers';\n\n/**\n * Call [Client#subscribe]{@link Client#subscribe} to create a StompSubscription.\n *\n * Part of `@stomp/stompjs`.\n */\nexport class StompSubscription {\n  /**\n   * Id associated with this subscription.\n   */\n  public id: string;\n\n  /**\n   * Unsubscribe. See [Client#unsubscribe]{@link Client#unsubscribe} for an example.\n   */\n  public unsubscribe: (headers?: StompHeaders) => void;\n}\n","/**\n * STOMP headers. Many functions calls will accept headers as parameters.\n * The headers sent by Broker will be available as [Frame#headers]{@link Frame#headers}.\n *\n * `key` and `value` must be valid strings.\n * In addition, `key` must not contain `CR`, `LF`, or `:`.\n *\n * Part of `@stomp/stompjs`.\n */\nexport class StompHeaders { [key: string]: string }\n","import {StompHeaders} from './stomp-headers';\nimport {\n  closeEventCallbackType,\n  debugFnType,\n  frameCallbackType,\n  messageCallbackType\n} from './types';\nimport {Versions} from './versions';\n\n/**\n * Configuration options for STOMP Client, each key corresponds to\n * field by the same name in {@link Client}. This can be passed to\n * the constructor of {@link Client} or to [Client#configure]{@link Client#configure}.\n *\n * Part of `@stomp/stompjs`.\n */\nexport class StompConfig {\n  /**\n   * See [Client#brokerURL]{@link Client#brokerURL}.\n   */\n  public brokerURL?: string;\n\n  /**\n   * See See [Client#stompVersions]{@link Client#stompVersions}.\n   */\n  public stompVersions?: Versions;\n\n  /**\n   * See [Client#webSocketFactory]{@link Client#webSocketFactory}.\n   */\n  public webSocketFactory?: () => any;\n\n  /**\n   * See [Client#reconnectDelay]{@link Client#reconnectDelay}.\n   */\n  public reconnectDelay?: number;\n\n  /**\n   * See [Client#heartbeatIncoming]{@link Client#heartbeatIncoming}.\n   */\n  public heartbeatIncoming?: number;\n\n  /**\n   * See [Client#heartbeatOutgoing]{@link Client#heartbeatOutgoing}.\n   */\n  public heartbeatOutgoing?: number;\n\n  /**\n   * See [Client#connectHeaders]{@link Client#connectHeaders}.\n   */\n  public connectHeaders?: StompHeaders;\n\n  /**\n   * See [Client#disconnectHeaders]{@link Client#disconnectHeaders}.\n   */\n  public disconnectHeaders?: StompHeaders;\n\n  /**\n   * See [Client#onUnhandledMessage]{@link Client#onUnhandledMessage}.\n   */\n  public onUnhandledMessage?: messageCallbackType;\n\n  /**\n   * See [Client#onUnhandledReceipt]{@link Client#onUnhandledReceipt}.\n   */\n  public onUnhandledReceipt?: frameCallbackType;\n\n  /**\n   * See [Client#onUnhandledFrame]{@link Client#onUnhandledFrame}.\n   */\n  public onUnhandledFrame?: frameCallbackType;\n\n  /**\n   * See [Client#beforeConnect]{@link Client#beforeConnect}.\n   */\n  public beforeConnect?: () => void;\n\n  /**\n   * See [Client#onConnect]{@link Client#onConnect}.\n   */\n  public onConnect?: frameCallbackType;\n\n  /**\n   * See [Client#onDisconnect]{@link Client#onDisconnect}.\n   */\n  public onDisconnect?: frameCallbackType;\n\n  /**\n   * See [Client#onStompError]{@link Client#onStompError}.\n   */\n  public onStompError?: frameCallbackType;\n\n  /**\n   * See [Client#onWebSocketClose]{@link Client#onWebSocketClose}.\n   */\n  public onWebSocketClose?: closeEventCallbackType;\n\n  /**\n   * See [Client#debug]{@link Client#debug}.\n   */\n  public debug?: debugFnType;\n}\n","import {Frame} from './frame';\nimport {StompHeaders} from './stomp-headers';\n\n/**\n * Instance of Message will be passed to [subscription callback]{@link Client#subscribe}\n * and [Client#onUnhandledMessage]{@link Client#onUnhandledMessage}.\n * Since it is an extended {@link Frame}, you can access [headers]{@link Frame#headers}\n * and [body]{@link Frame#body} as properties.\n *\n * Part of `@stomp/stompjs`.\n *\n * See [Client#subscribe]{@link Client#subscribe} for example.\n */\nexport class Message extends Frame {\n  /**\n   * When subscribing with manual acknowledgement, call this method on the message to ACK the message.\n   *\n   * See [Client#ack]{@link Client#ack} for an example.\n   */\n  public ack: (headers?: StompHeaders) => void;\n\n  /**\n   * When subscribing with manual acknowledgement, call this method on the message to NACK the message.\n   *\n   * See [Client#nack]{@link Client#nack} for an example.\n   */\n  public nack: (headers?: StompHeaders) => void;\n}\n","import {BYTE} from './byte';\nimport {Client} from './client';\nimport {Frame} from './frame';\nimport {Message} from './message';\nimport {Parser} from './parser';\nimport {StompConfig} from './stomp-config';\nimport {StompHeaders} from './stomp-headers';\nimport {StompSubscription} from './stomp-subscription';\nimport {Transaction} from './transaction';\nimport {closeEventCallbackType, debugFnType, frameCallbackType, IPublishParams, messageCallbackType} from './types';\nimport {Versions} from './versions';\n\n/**\n * The STOMP protocol handler\n *\n * Part of `@stomp/stompjs`.\n *\n * @internal\n */\nexport class StompHandler {\n  public debug: debugFnType;\n\n  public stompVersions: Versions;\n\n  public connectHeaders: StompHeaders;\n\n  public disconnectHeaders: StompHeaders;\n\n  public heartbeatIncoming: number;\n\n  public heartbeatOutgoing: number;\n\n  public onUnhandledMessage: messageCallbackType;\n\n  public onUnhandledReceipt: frameCallbackType;\n\n  public onUnhandledFrame: frameCallbackType;\n\n  public onConnect: frameCallbackType;\n\n  public onDisconnect: frameCallbackType;\n\n  public onStompError: frameCallbackType;\n\n  public onWebSocketClose: closeEventCallbackType;\n\n  get connectedVersion(): string {\n    return this._connectedVersion;\n  }\n  private _connectedVersion: string;\n\n  get connected(): boolean {\n    return this._connected;\n  }\n\n  private _connected: boolean;\n\n  private readonly _subscriptions: { [key: string]: messageCallbackType };\n  private readonly _receiptWatchers: { [key: string]: frameCallbackType };\n  private _partialData: string;\n  private _escapeHeaderValues: boolean;\n  private _counter: number;\n  private _pinger: any;\n  private _ponger: any;\n  private _lastServerActivityTS: number;\n\n  constructor(private _client: Client, private _webSocket: WebSocket, config: StompConfig = {}) {\n    // used to index subscribers\n    this._counter = 0;\n\n    // subscription callbacks indexed by subscriber's ID\n    this._subscriptions = {};\n\n    // receipt-watchers indexed by receipts-ids\n    this._receiptWatchers = {};\n\n    this._partialData = '';\n\n    this._escapeHeaderValues = false;\n\n    this._lastServerActivityTS = Date.now();\n\n    this.configure(config);\n  }\n\n  public configure(conf: StompConfig): void {\n    // bulk assign all properties to this\n    (Object as any).assign(this, conf);\n  }\n\n  public start(): void {\n    const parser = new Parser(\n      // On Frame\n      (rawFrame) => {\n        const frame = Frame.fromRawFrame(rawFrame, this._escapeHeaderValues);\n\n        this.debug(`<<< ${frame}`);\n\n        const serverFrameHandler = this._serverFrameHandlers[frame.command] || this.onUnhandledFrame;\n        serverFrameHandler(frame);\n      },\n      // On Incoming Ping\n      () => {\n        this.debug('<<< PONG');\n      }\n    );\n\n    this._webSocket.onmessage = (evt: any) => {\n      this.debug('Received data');\n      this._lastServerActivityTS = Date.now();\n\n      parser.parseChunk(evt.data);\n    };\n\n    this._webSocket.onclose = (closeEvent: any): void => {\n      this.debug(`Connection closed to ${this._webSocket.url}`);\n      this.onWebSocketClose(closeEvent);\n      this._cleanUp();\n    };\n\n    this._webSocket.onopen = () => {\n      // Clone before updating\n      const connectHeaders = (Object as any).assign({}, this.connectHeaders);\n\n      this.debug('Web Socket Opened...');\n      connectHeaders['accept-version'] = this.stompVersions.supportedVersions();\n      connectHeaders['heart-beat'] = [this.heartbeatOutgoing, this.heartbeatIncoming].join(',');\n      this._transmit({command: 'CONNECT', headers: connectHeaders});\n    };\n  }\n\n  private readonly _serverFrameHandlers: { [key: string]: frameCallbackType } = {\n\n    // [CONNECTED Frame](http://stomp.github.com/stomp-specification-1.2.html#CONNECTED_Frame)\n    CONNECTED: (frame) => {\n      this.debug(`connected to server ${frame.headers.server}`);\n      this._connected = true;\n      this._connectedVersion = frame.headers.version;\n      // STOMP version 1.2 needs header values to be escaped\n      if (this._connectedVersion === Versions.V1_2) {\n        this._escapeHeaderValues = true;\n      }\n\n      this._setupHeartbeat(frame.headers);\n      this.onConnect(frame);\n    },\n\n    // [MESSAGE Frame](http://stomp.github.com/stomp-specification-1.2.html#MESSAGE)\n    MESSAGE: (frame) => {\n      // the callback is registered when the client calls\n      // `subscribe()`.\n      // If there is no registered subscription for the received message,\n      // the default `onUnhandledMessage` callback is used that the client can set.\n      // This is useful for subscriptions that are automatically created\n      // on the browser side (e.g. [RabbitMQ's temporary\n      // queues](http://www.rabbitmq.com/stomp.html)).\n      const subscription = frame.headers.subscription;\n      const onReceive = this._subscriptions[subscription] || this.onUnhandledMessage;\n\n      // bless the frame to be a Message\n      const message = frame as Message;\n\n      const client = this;\n      const messageId = this._connectedVersion === Versions.V1_2 ? message.headers.ack : message.headers['message-id'];\n\n      // add `ack()` and `nack()` methods directly to the returned frame\n      // so that a simple call to `message.ack()` can acknowledge the message.\n      message.ack = (headers: StompHeaders = {}): void => {\n        return client.ack(messageId, subscription, headers);\n      };\n      message.nack = (headers: StompHeaders = {}): void => {\n        return client.nack(messageId, subscription, headers);\n      };\n      onReceive(message);\n    },\n\n    // [RECEIPT Frame](http://stomp.github.com/stomp-specification-1.2.html#RECEIPT)\n    RECEIPT: (frame) => {\n      const callback = this._receiptWatchers[frame.headers['receipt-id']];\n      if (callback) {\n        callback(frame);\n        // Server will acknowledge only once, remove the callback\n        delete this._receiptWatchers[frame.headers['receipt-id']];\n      } else {\n        this.onUnhandledReceipt(frame);\n      }\n    },\n\n    // [ERROR Frame](http://stomp.github.com/stomp-specification-1.2.html#ERROR)\n    ERROR: (frame) => {\n      this.onStompError(frame);\n    }\n  };\n\n  private _setupHeartbeat(headers: StompHeaders): void {\n    if ((headers.version !== Versions.V1_1 && headers.version !== Versions.V1_2)) {\n      return;\n    }\n\n    // heart-beat header received from the server looks like:\n    //\n    //     heart-beat: sx, sy\n    const [serverOutgoing, serverIncoming] = (headers['heart-beat']).split(',').map((v: string) => parseInt(v, 10));\n\n    if ((this.heartbeatOutgoing !== 0) && (serverIncoming !== 0)) {\n      const ttl: number = Math.max(this.heartbeatOutgoing, serverIncoming);\n      this.debug(`send PING every ${ttl}ms`);\n      this._pinger = setInterval(() => {\n        this._webSocket.send(BYTE.LF);\n        this.debug('>>> PING');\n      }, ttl);\n    }\n\n    if ((this.heartbeatIncoming !== 0) && (serverOutgoing !== 0)) {\n      const ttl: number = Math.max(this.heartbeatIncoming, serverOutgoing);\n      this.debug(`check PONG every ${ttl}ms`);\n      this._ponger = setInterval(() => {\n        const delta = Date.now() - this._lastServerActivityTS;\n        // We wait twice the TTL to be flexible on window's setInterval calls\n        if (delta > (ttl * 2)) {\n          this.debug(`did not receive server activity for the last ${delta}ms`);\n          this._webSocket.close();\n        }\n      }, ttl);\n    }\n  }\n\n  private _transmit(params: { command: string, headers?: StompHeaders,\n                              body?: string, binaryBody?: Uint8Array, skipContentLengthHeader?: boolean }): void {\n    const {command, headers, body, binaryBody, skipContentLengthHeader} = params;\n    const frame = new Frame({\n      command,\n      headers,\n      body,\n      binaryBody,\n      escapeHeaderValues: this._escapeHeaderValues,\n      skipContentLengthHeader\n    });\n    this.debug(`>>> ${frame}`);\n    this._webSocket.send(frame.serialize());\n/* Do we need this?\n    // if necessary, split the *STOMP* frame to send it on many smaller\n    // *WebSocket* frames\n    while (true) {\n      if (out.length > this.maxWebSocketFrameSize) {\n        this._webSocket.send(out.substring(0, this.maxWebSocketFrameSize));\n        out = out.substring(this.maxWebSocketFrameSize);\n        this.debug(`remaining = ${out.length}`);\n      } else {\n        this._webSocket.send(out);\n        return;\n      }\n    }\n*/\n  }\n\n  public dispose(): void {\n    if (this.connected) {\n      try {\n        // clone before updating\n        const disconnectHeaders = (Object as any).assign({}, this.disconnectHeaders);\n\n        if (!disconnectHeaders.receipt) {\n          disconnectHeaders.receipt = `close-${this._counter++}`;\n        }\n        this.watchForReceipt(disconnectHeaders.receipt, (frame) => {\n          this._webSocket.close();\n          this._cleanUp();\n          this.onDisconnect(frame);\n        });\n        this._transmit({command: 'DISCONNECT', headers: disconnectHeaders});\n      } catch (error) {\n        this.debug(`Ignoring error during disconnect ${error}`);\n      }\n    } else {\n      if (this._webSocket.readyState === WebSocket.CONNECTING || this._webSocket.readyState === WebSocket.OPEN) {\n        this._webSocket.close();\n      }\n    }\n  }\n\n  private _cleanUp() {\n    this._connected = false;\n\n    if (this._pinger) {\n      clearInterval(this._pinger);\n    }\n    if (this._ponger) {\n      clearInterval(this._ponger);\n    }\n  }\n\n  public publish(params: IPublishParams): void {\n    const {destination, headers, body, binaryBody, skipContentLengthHeader} = params;\n    const hdrs: StompHeaders = (Object as any).assign({destination}, headers);\n    this._transmit({\n      command: 'SEND',\n      headers: hdrs,\n      body,\n      binaryBody,\n      skipContentLengthHeader\n    });\n  }\n\n  public watchForReceipt(receiptId: string, callback: frameCallbackType): void {\n    this._receiptWatchers[receiptId] = callback;\n  }\n\n  public subscribe(destination: string, callback: messageCallbackType, headers: StompHeaders = {}): StompSubscription {\n    headers = (Object as any).assign({}, headers);\n\n    if (!headers.id) {\n      headers.id = `sub-${this._counter++}`;\n    }\n    headers.destination = destination;\n    this._subscriptions[headers.id] = callback;\n    this._transmit({command: 'SUBSCRIBE', headers});\n    const client = this;\n    return {\n      id: headers.id,\n\n      unsubscribe(hdrs) {\n        return client.unsubscribe(headers.id, hdrs);\n      }\n    };\n  }\n\n  public unsubscribe(id: string, headers: StompHeaders = {}): void {\n    headers = (Object as any).assign({}, headers);\n\n    delete this._subscriptions[id];\n    headers.id = id;\n    this._transmit({command: 'UNSUBSCRIBE', headers});\n  }\n\n  public begin(transactionId: string): Transaction {\n    const txId = transactionId || (`tx-${this._counter++}`);\n    this._transmit({\n      command: 'BEGIN', headers: {\n        transaction: txId\n      }\n    });\n    const client = this;\n    return {\n      id: txId,\n      commit(): void {\n        client.commit(txId);\n      },\n      abort(): void {\n        client.abort(txId);\n      }\n    };\n  }\n\n  public commit(transactionId: string): void {\n    this._transmit({\n      command: 'COMMIT', headers: {\n        transaction: transactionId\n      }\n    });\n  }\n\n  public abort(transactionId: string): void {\n    this._transmit({\n      command: 'ABORT', headers: {\n        transaction: transactionId\n      }\n    });\n  }\n\n  public ack(messageId: string, subscriptionId: string, headers: StompHeaders = {}): void {\n    headers = (Object as any).assign({}, headers);\n\n    if (this._connectedVersion === Versions.V1_2) {\n      headers.id = messageId;\n    } else {\n      headers['message-id'] = messageId;\n    }\n    headers.subscription = subscriptionId;\n    this._transmit({command: 'ACK', headers});\n  }\n\n  public nack(messageId: string, subscriptionId: string, headers: StompHeaders = {}): void {\n    headers = (Object as any).assign({}, headers);\n\n    if (this._connectedVersion === Versions.V1_2) {\n      headers.id = messageId;\n    } else {\n      headers['message-id'] = messageId;\n    }\n    headers.subscription = subscriptionId;\n    return this._transmit({command: 'NACK', headers});\n  }\n\n}\n","export * from './client';\nexport * from './frame';\nexport * from './message';\nexport * from './parser';\nexport * from './stomp-config';\nexport * from './stomp-headers';\nexport * from './stomp-subscription';\nexport * from './transaction';\nexport * from './types';\nexport * from './versions';\n\n// Compatibility code\nexport * from './compatibility/compat-client';\nexport * from './compatibility/stomp';\n"],"sourceRoot":""}